<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mr Xie Blog</title>
    <description>关于程序与设计、黑客与画家 | 黄玄，Web &amp; Mobile Lover，Software Engineer，UX Designer | 这里是 @Hux黄玄 的个人博客，与你一起发现更大的世界。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 05 Aug 2019 23:06:54 +0800</pubDate>
    <lastBuildDate>Mon, 05 Aug 2019 23:06:54 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Golang 是否有必要内存对齐？</title>
        <description>&lt;p&gt;有些同学可能不知道，struct 中的字段顺序不同，内存占用也有可能会相差很大。比如：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int8&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int16&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int8&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int16&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 64 bit 平台上，T1 占用 24 bytes，T2 占用 16 bytes 大小；而在 32 bit 平台上，T1 占用 16 bytes，T2 占用 12 bytes 大小。&lt;strong&gt;可见不同的字段顺序，最终决定 struct 的内存大小，所以有时候合理的字段顺序可以减少内存的开销&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这是为什么呢？&lt;u&gt;因为有内存对齐的存在，编译器使用了内存对齐，那么最后的大小结果就会不一样&lt;/u&gt;。至于为什么要做对齐，主要考虑下面两个原因：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;平台（移植性）&lt;/p&gt;

    &lt;p&gt;不是所有的硬件平台都能够访问任意地址上的任意数据。例如：特定的硬件平台只允许在特定地址获取特定类型的数据，否则会导致异常情况&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;性能&lt;/p&gt;

    &lt;p&gt;若访问未对齐的内存，将会导致 CPU 进行两次内存访问，并且要花费额外的时钟周期来处理对齐及运算。而本身就对齐的内存仅需要一次访问就可以完成读取动作，这显然高效很多，是标准的空间换时间做法&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;有的小伙伴可能会认为内存读取，就是一个简单的字节数组摆放。但实际上 CPU 并不会以一个一个字节去读取和写入内存，相反 CPU 读取内存是一块一块读取的，块的大小可以为 2、4、6、8、16 字节等大小，块大小我们称其为内存访问粒度。假设访问粒度为 4，那么 CPU 就会以每 4 个字节大小的访问粒度去读取和写入内存。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在不同平台上的编译器都有自己默认的 “对齐系数”。一般来讲，我们常用的 x86 平台的系数为 4；x86_64 平台系数为 8。需要注意的是，除了这个默认的对齐系数外，还有不同数据类型的对齐系数。数据类型的对齐系数在不同平台上可能会不一致。例如，在 x86_64 平台上，int64 的对齐系数为 8，而在 x86 平台上其对齐系数就是 4。&lt;/p&gt;

&lt;p&gt;还是拿上面的 T1、T2 来说，在 x86_64 平台上，T1 的内存布局为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/memory-alignment/T1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;T2 的内存布局为（int16 的对齐系数为 2）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/memory-alignment/T2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;仔细看，T1 存在许多 padding，显然它占据了不少空间。那么也就不难理解，为什么调整结构体内成员变量的字段顺序就能达到缩小结构体占用大小的疑问了，是因为巧妙地减少了 padding 的存在。让它们更 “紧凑” 了。&lt;/p&gt;

&lt;p&gt;其实内存对齐除了可以降低内存占用之外，还有一种情况是必须要手动对齐的：&lt;strong&gt;在 x86 平台上原子操作 64bit 指针。之所以要强制对齐，是因为在 32bit 平台下进行 64bit 原子操作要求必须 8 字节对齐，否则程序会 panic&lt;/strong&gt;。详情可以参考 &lt;a href=&quot;https://godoc.org/sync/atomic#pkg-note-bug&quot;&gt;atomic&lt;/a&gt; 官方文档（这么重要的信息竟然放在页面的最底部！！！😱）：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Bugs&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;On x86-32, the 64-bit functions use instructions unavailable before the Pentium MMX. On non-Linux ARM, the 64-bit functions use instructions unavailable before the ARMv6k core. On ARM, x86-32, and 32-bit MIPS, it is the caller’s responsibility to arrange for 64-bit alignment of 64-bit words accessed atomically. The first word in a variable or in an allocated struct, array, or slice can be relied upon to be 64-bit aligned.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;比如，下面这段代码：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;sync/atomic&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T3&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int32&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddInt64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;编译为 64bit 可执行文件，运行没有任何问题；但是当编译为 32bit 可执行文件，运行就会 panic:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ GOARCH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;386 go build aligned.go
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./aligned
panic: runtime error: invalid memory address or nil pointer dereference
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;signal SIGSEGV: segmentation violation &lt;span class=&quot;nv&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0x1 &lt;span class=&quot;nv&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0x0 &lt;span class=&quot;nv&quot;&gt;pc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0x8049f2c]

goroutine 1 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;running]:
runtime/internal/atomic.Xadd64&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0x941218c, 0x1, 0x0, 0x809a4c0, 0x944e070&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	/usr/local/go/src/runtime/internal/atomic/asm_386.s:105 +0xc
main.main&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
	/root/gofourge/src/lab/archive/aligned.go:18 +0x42
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;原因就是 T3 在 32bit 平台上是 4 字节对齐，而在 64bit 平台上是 8 字节对齐。在 64bit 平台上其内存布局为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/memory-alignment/T3-x86_64.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到编译器为了让 d 8 字节对齐，在 c 后面 padding 了 4 个字节。而在 32bit 平台上其内存布局为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/memory-alignment/T3-x86.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;编译器用的是 4 字节对齐，所以 c 后面 4 个字节并没有 padding，而是直接排列 d 的高低位字节。&lt;/p&gt;

&lt;p&gt;为了解决这种情况，我们必须手动 padding T3，让其 “看起来” 像是 8 字节对齐的：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T3&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int32&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int32&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样 T3 的内存布局就变成了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/memory-alignment/T3-x86-8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看起来就像 8 字节对齐了一样，这样就能完美兼容 32bit 平台了。其实很多知名的项目，都是这么处理的，比如 &lt;a href=&quot;https://github.com/golang/groupcache/blob/869f871628b6baa9cfbc11732cdf6546b17c1298/groupcache.go#L169-L172&quot;&gt;groupcache&lt;/a&gt;：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int32&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// force Stats to be 8-byte aligned on 32-bit platforms&lt;/span&gt;

	&lt;span class=&quot;c&quot;&gt;// Stats are statistics on the group.&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Stats&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stats&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;说了这么多，但是在我们实际编码的时候，多数情况都不会考虑到最优的内存对齐。那有没有什么办法能自动检测当前的内存布局是最优呢？答案是：有的。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://golang-sizeof.tips/&quot;&gt;golang-sizeof.tips&lt;/a&gt; 这个网站就可以可视化 struct 的内存布局，但是只支持 8 字节对齐，是个缺点。还有一种方法，就是用 golangci-lint 做静态检测，比如在我的一个项目中检测结果是这样的：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;golangci-lint run &lt;span class=&quot;nt&quot;&gt;--disable-all&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-E&lt;/span&gt; maligned
config/config.go:79:11: struct of size 48 bytes could be of size 40 bytes &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;maligned&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;type &lt;/span&gt;SASL struct &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          ^
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;提示有一处 struct 可以优化，来看一下这个 struct 的定义：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SASL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Enable&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Username&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Password&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Handshake&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过 &lt;a href=&quot;http://golang-sizeof.tips/&quot;&gt;golang-sizeof.tips&lt;/a&gt; 对比，显然字段按照下面这样排序更为合理：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SASL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Username&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Password&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Handshake&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Enable&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;参考文献&quot;&gt;参考文献&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.chewxy.com/2016/07/25/on-the-memory-alignment-of-go-slice-values/&quot;&gt;On the memory alignment of Go slice values&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://go101.org/article/memory-layout.html&quot;&gt;Memory Layouts&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/golang/go/issues/11891&quot;&gt;cmd/vet: detect non-64-bit-aligned arguments to sync/atomic funcs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://dave.cheney.net/2015/10/09/padding-is-hard&quot;&gt;Padding is hard&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://eddycjy.gitbook.io/golang/di-1-ke-za-tan/go-memory-align&quot;&gt;在 Go 中恰到好处的内存对齐&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.flysnow.org/2017/07/02/go-in-action-unsafe-memory-layout.html&quot;&gt;Go unsafe 包之内存布局&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 01 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/08/01/golang-memory-alignment/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/08/01/golang-memory-alignment/</guid>
        
        <category>Golang</category>
        
        <category>Atomicity</category>
        
        
      </item>
    
  </channel>
</rss>
